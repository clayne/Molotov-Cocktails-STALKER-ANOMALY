local enable_debug = false
local print_tip = function(s, ...)
    local f = print_tip or printf
    if enable_debug then
        return f("Geometry Ray: " .. s, ...)
    end
end

-- Geometry Ray class by Thial, edited by demonized
class "geometry_ray"

--[[
(At least one range parameter should be specified)
ray_range:
    Defines the total range of the ray. If you want to attach the ray to
    a fast moving object it is good to extend the ray so that you can reduce
    the polling rate by using the get function.
contact_range:
    Defines the distance at which the result will report being in contact.
    You can skip it or set it to a value lower than the ray_range to
    still be able to get the intersection position from the result while
    marking the ray as not being in contact yet
distance_offset:
    Defines how much the intersection position is offset.
    You can use both positive and negative values or you can leave it blank.
flags (bit map = values can be added together for combined effect):
    0 : None
    1 : Objects
    2 : Statics
    4 : Shapes
    8 : Obstacles
]]--
function geometry_ray:__init(args)
    local args = args or {}
    if args.ray_range == nil and args.contact_range == nil then
        return nil
    end

    self.ray_range = args.ray_range or args.contact_range
    self.contact_range = args.contact_range or args.ray_range
    self.distance_offset = args.distance_offset ~= nil and args.distance_offset or 0
    self.ray = ray_pick()
    self.ray:set_flags(args.flags or 2)
    self.ray:set_range(self.ray_range)
    self.visualize = args.visualize
    if args.ignore_object then
        self.ray:set_ignore_object(args.ignore_object)
    end
end

--[[
position:
    position from which the ray will start
direction:
    direction in which the ray will be fired
]]--
function geometry_ray:get(position, direction)    
    if position == nil or direction == nil then
        return nil
    end

    local position = vector():set(position)
    local direction = vector():set(direction)

    self.ray:set_position(position)
    self.ray:set_direction(direction)
    local res = self.ray:query()
    local distance = res and self.ray:get_distance() or self.ray_range
    local result = {}
    if self.visualize then
        local init_pos = vector():set(position)
        local end_pos = vector():mad(init_pos, direction, distance)
        VisualizeRay(init_pos, end_pos)
    end
    result.in_contact = distance <= self.contact_range
    result.position = position:add(direction:mul(distance + self.distance_offset))
    result.distance = distance
    result.raw_distance = self.ray:get_distance()
    result.success = res
    result.object = self.ray:get_object()
    result.element = self.ray:get_element()
    result.result = self.ray:get_result()
    return result
end

-- Utils
-- Check if values are similar to a precision
function similar(float1, float2, epsilon)
    return math.abs(float1 - float2) <= (epsilon or 0.0001)
end

function vec_similar(vec1, vec2, epsilon)
    return similar(vec1.x, vec2.x, epsilon) and similar(vec1.y, vec2.y, epsilon) and similar(vec1.z, vec2.z, epsilon)
end

-- Linear inter/extrapolation
function lerp(a, b, f)
    if a and b and f then
        return a + f * (b - a)
    else
        return a or b or 0
    end
end

-- Visualize ray from one point to other with particles playing at setted step
class "VisualizeRay"
function VisualizeRay:__init(init_pos, end_pos, particle_step, visualize_time, force_stop)
    self.init_pos = init_pos
    self.end_pos = end_pos
    self.visualize_time = visualize_time or 3000
    self.particle_step = particle_step or 0.02
    self.force_stop = force_stop
    self.force_stop_default = force_stop
    self.time = 0

    self.start = function()
        for i = 0, 1, self.particle_step do
            local p = particles_object("amik\\hit_fx\\metal\\hit_sparks_glow")
            local x = lerp(self.init_pos.x, self.end_pos.x, i)
            local y = lerp(self.init_pos.y, self.end_pos.y, i)
            local z = lerp(self.init_pos.z, self.end_pos.z, i)
            p:play_at_pos(vector():set(x, y, z))
            local time = 0
            local stopped = false
            AddUniqueCall(function()
                if self.time > self.visualize_time then
                    if not stopped then
                        if self.force_stop then p:stop() else p:stop_deffered() end
                        stopped = true
                    end
                    if not p:playing() then
                        p = nil
                        return true
                    end
                else
                    if not p:playing() then
                        p:play_at_pos(vector():set(x, y, z))
                    end
                    time = time + device().time_delta
                    self.time = time
                end
            end)
        end
    end
    self.start()

    self.reset_time = function()
        self.time = 0
    end

    self.reset = function()
        self.time = 0
        self.force_stop = self.force_stop_default
        self.start()
    end

    self.stop = function()
        self.time = self.visualize_time + 1
        self.force_stop = true
    end
end

-- Get surface normals by Aoldri, edited by demonized
function get_surface_normal(pos, dir)
    local ray = geometry_ray({
        ray_range = 1000,
        visualize = false,
    })

    -- Get player's camera position and direction in world space
    local pos0 = pos and vector():set(pos) or device().cam_pos
    local pos01 = vector():set(pos0):add(vector():set(0, 0.01, 0))
    local pos02 = vector():set(pos0):add(vector():set(0.01, 0, 0))
    local angle1 = dir and vector():set(dir) or device().cam_dir

    -- Get positions of intersections of rays angled above and to the left of pos1
    local res = ray:get(pos0, angle1)
    local pos1 = res.position
    local pos2 = ray:get(pos01, angle1).position
    local pos3 = ray:get(pos02, angle1).position

    if not res.success then
        -- print_tip("cant get normal by pos %s, dir %s", pos0, angle1)
        return
    end

    -- VisualizeRay(pos0, pos1, nil, 300)
    -- VisualizeRay(pos01, pos2, nil, 300)
    -- VisualizeRay(pos02, pos3, nil, 300)

    -- Get vectors from intersection points from pos1
    local vec2 = vec_sub(pos1, pos2)
    local vec3 = vec_sub(pos1, pos3)

    -- Find normal vector of surface by taking cross product of intersection vectors
    local cross = (vector_cross(vec2, vec3)):normalize()   

    -- If the direction and normal vectors heading in similar direction - invert normal
    local deg = angle1:dotproduct(cross)
    if deg > 0 then
        cross:invert()
    end

    -- VisualizeRay(pos1, vector():set(pos1):add(cross), nil, 300)
    return cross
end
